pymysql连接池

1.诞生
pymysql在测试数据过程中，使用普通的pymysql插入100W条数据，消耗时间很漫长，实测990s也就是16.5分钟左右才能插完，于是，脑海中诞生了一个想法，能不能造出一个连接池出来，提升数据呢？就像一根管道太小，那就多加几根管道看效果如何呢？于是。。。前前后后折腾了将近一天时间，就有了本文的诞生。。。

2.连接池及单例模式
先说单例模式吧，为什么要在这使用单例模式呢？使用单例模式能够节省资源。

其实单例模式没有什么神秘的，简单的单例模式实现其实就是在类里面定义一个变量，再定义一个类方法，这个类方法用来为调用者提供这个类的实例化对象。（ps:个人对单例模式的一点浅薄理解...）

那么连接池是怎么回事呢？原来使用pymysql创建一个conn对象的时候，就已经和mysql之间创建了一个tcp的长连接，只要不调用这个对象的close方法，这个长连接就不会断开，这样，我们创建了一组conn对象，并将这些conn对象放到队列里面去，这个队列现在就是一个连接池了。

现在，我们先用一个连接，往数据库中插入100W条数据，下面是源码：

复制代码
 1 import pymysql
 2 import time
 3 start=time.time()
 4 conn = pymysql.connect(host="192.168.10.103",port=3306,user="root",passwd="123456",db="sql_example",charset="utf8")
 5 conn.autocommit(True)  # 设置自动commit
 6 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)  # 设置返回的结果集用字典来表示，默认是元祖
 7 data=(("男",i,"张小凡%s" %i) for i in range(1000000))  # 伪造数据，data是个生成器
 8 cursor.executemany("insert into tb1(gender,class_id,sname) values(%s,%s,%s)",data)  # 可以使用executemany执行多条sql
 9 # conn.commit()
10 cursor.close()
11 conn.close()
12 print("totol time:",time.time()-start)
复制代码
 

执行结果为：

totol time: 978.7649309635162

3.多线程提升
使用多线程，在启动时创建一组线程，每个线程去连接池里面获取一个连接，然后插入数据，这样将会大大提升执行sql的速度，下面是使用多线程实现的连接池源码：

 显示代码
 

 

开启10个连接池插入100W数据的时间：

totol time: 242.81142950057983

开启50个连接池插入100W数据的时间：

totol time: 192.49499201774597

开启100个线程池插入100W数据的时间：

totol time: 191.73923873901367

4.协程提升
使用协程的话，在I/O阻塞时，将会切换到其他任务去执行，这样理论上来说消耗的资源应该会比多线程要少。下面是协程实现的连接池源代码：

 显示代码
 

 

开启10个连接池插入100W数据的时间：

totol time: 240.16892313957214

开启50个连接池插入100W数据的时间：

totol time: 202.82087111473083

开启100个线程池插入100W数据的时间：

totol time: 196.1710569858551

5.后记
统计结果如下：

单线程一个连接使用时间：978.76s

 	10个连接池	50个连接池	100个连接池
多线程版	242.81s	192.49s	191.74s
协程版	240.17s	202.82s	196.17s
通过统计结果显示,通过协程和多线程操作连接池插入相同数据，相对一个连接提升速度明显，但是在将连接池开到50以及100时，性能提升并没有想象中那么大，这时候，瓶颈已经不在网络I/O上了，而在数据库中，mysql在大量连接写入数据时，也会有锁的产生，这时候就需要优化数据库的相关设置了。

在对比中显示多线程利用线程池和协程利用线程池的性能差不多，但是多线程的开销比协程要大。

和大神讨论过，在项目开发中需要考虑到不同情况使用不同的技术，多线程适合使用在连接量较大，但每个连接处理时间很短的情况下，而协程适用于处理大量连接，但同时活跃的链接比较少，并且每个连接的时间量比较大的情况下。

在实际生产应用中，创建连接池可以按需分配，当连接不够用时，在连接池没达到上限的情况下，在连接池里面加入新的连接，在连接池比较空闲的情况下，关闭一些连接，实现这一个操作的原理是通过queue里面的超时时间来控制，当等待时间超过了超时时间时，说明连接不够用了，需要加入新的连接。
